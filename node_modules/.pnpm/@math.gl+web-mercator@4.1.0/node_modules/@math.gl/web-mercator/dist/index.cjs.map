{
  "version": 3,
  "sources": ["../src/index.ts", "../src/math-utils.ts", "../src/web-mercator-utils.ts", "../src/assert.ts", "../src/fit-bounds.ts", "../src/get-bounds.ts", "../src/web-mercator-viewport.ts", "../src/normalize-viewport-props.ts", "../src/fly-to-viewport.ts"],
  "sourcesContent": ["// Classic web-mercator-project\nexport {WebMercatorViewport} from './web-mercator-viewport';\n\nexport {getBounds} from './get-bounds';\nexport {fitBounds} from './fit-bounds';\nexport {normalizeViewportProps} from './normalize-viewport-props';\nexport {flyToViewport, getFlyToDuration} from './fly-to-viewport';\n\nexport {\n  MAX_LATITUDE,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  pixelsToWorld,\n  zoomToScale,\n  scaleToZoom,\n  altitudeToFovy,\n  fovyToAltitude,\n  getMeterZoom,\n  unitsPerMeter,\n  getDistanceScales,\n  addMetersToLngLat,\n  getViewMatrix,\n  getProjectionMatrix,\n  getProjectionParameters\n} from './web-mercator-utils';\n\n/** Types */\nexport type {FitBoundsOptions} from './fit-bounds';\nexport type {DistanceScales} from './web-mercator-utils';\n\n/** @deprecated default export */\nexport {WebMercatorViewport as default} from './web-mercator-viewport';\n", "import {vec4} from '@math.gl/core';\n\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nexport function createMat4(): number[] {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\n// Transforms a vec4 with a projection matrix\nexport function transformVector(matrix: number[], vector: number[]): number[] {\n  const result = vec4.transformMat4([] as number[], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}\n\nexport function mod(value: number, divisor: number): number {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\n\nexport function lerp(start: number, end: number, step: number): number {\n  return step * end + (1 - step) * start;\n}\n\nexport function clamp(x: number, min: number, max: number): number {\n  return x < min ? min : x > max ? max : x;\n}\n\nfunction ieLog2(x: number): number {\n  return Math.log(x) * Math.LOG2E;\n}\n// Handle missing log2 in IE 11\nexport const log2 = Math.log2 || ieLog2;\n", "// TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE\n\nimport {createMat4, transformVector, clamp, log2} from './math-utils';\n\nimport {mat4, vec2, vec3} from '@math.gl/core';\nimport {assert} from './assert';\n\n// CONSTANTS\nconst PI = Math.PI;\nconst PI_4 = PI / 4;\nconst DEGREES_TO_RADIANS = PI / 180;\nconst RADIANS_TO_DEGREES = 180 / PI;\nconst TILE_SIZE = 512;\n// Average circumference (40075 km equatorial, 40007 km meridional)\nconst EARTH_CIRCUMFERENCE = 40.03e6;\n// Latitude that makes a square world, 2 * atan(E ** PI) - PI / 2\nexport const MAX_LATITUDE = 85.051129;\n\n// Mapbox default altitude\nexport const DEFAULT_ALTITUDE = 1.5;\n\nexport type DistanceScales = {\n  unitsPerMeter: number[];\n  metersPerUnit: number[];\n  unitsPerMeter2?: number[];\n  unitsPerDegree: number[];\n  degreesPerUnit: number[];\n  unitsPerDegree2?: number[];\n};\n\n/**\n * PROJECTION MATRIX PARAMETERS\n *\n * TODO how to document mebers\n * @param fov in radians. fov is variable, depends on pitch and altitude\n * @param aspect width/height\n * @param focalDistance distance at which visual scale factor is 1\n * @param near near clipping plane\n * @param far far clipping plane\n */\ntype ProjectionParameters = {\n  fov: number;\n  aspect: number;\n  focalDistance: number;\n  near: number;\n  far: number;\n};\n\n/** Logarithimic zoom to linear scale **/\nexport function zoomToScale(zoom: number): number {\n  return Math.pow(2, zoom);\n}\n\n/** Linear scale to logarithimic zoom **/\nexport function scaleToZoom(scale: number): number {\n  return log2(scale);\n}\n\n/**\n * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n * Performs the nonlinear part of the web mercator projection.\n * Remaining projection is done with 4x4 matrices which also handles\n * perspective.\n *\n * @param lngLat - [lng, lat] coordinates\n *   Specifies a point on the sphere to project onto the map.\n * @return [x,y] coordinates.\n */\nexport function lngLatToWorld(lngLat: number[]): [number, number] {\n  const [lng, lat] = lngLat;\n  assert(Number.isFinite(lng));\n  assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');\n\n  const lambda2 = lng * DEGREES_TO_RADIANS;\n  const phi2 = lat * DEGREES_TO_RADIANS;\n  const x = (TILE_SIZE * (lambda2 + PI)) / (2 * PI);\n  const y = (TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5)))) / (2 * PI);\n  return [x, y];\n}\n\n/**\n * Unproject world point [x,y] on map onto {lat, lon} on sphere\n *\n * @param xy - array with [x,y] members\n *  representing point on projected map plane\n * @return - array with [x,y] of point on sphere.\n *   Has toArray method if you need a GeoJSON Array.\n *   Per cartographic tradition, lat and lon are specified as degrees.\n */\nexport function worldToLngLat(xy: number[]): [number, number] {\n  const [x, y] = xy;\n  const lambda2 = (x / TILE_SIZE) * (2 * PI) - PI;\n  const phi2 = 2 * (Math.atan(Math.exp((y / TILE_SIZE) * (2 * PI) - PI)) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\n\n/**\n * Returns the zoom level that gives a 1 meter pixel at a certain latitude\n * 1 = C*cos(y)/2^z/TILE_SIZE = C*cos(y)/2^(z+9)\n */\nexport function getMeterZoom(options: {latitude: number}): number {\n  const {latitude} = options;\n  assert(Number.isFinite(latitude));\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;\n}\n\n/**\n * Calculate the conversion from meter to common units at a given latitude\n * This is a cheaper version of `getDistanceScales`\n * @param latitude center latitude in degrees\n * @returns common units per meter\n */\nexport function unitsPerMeter(latitude: number): number {\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;\n}\n\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\nexport function getDistanceScales(options: {\n  latitude: number;\n  longitude: number;\n  highPrecision?: boolean;\n}): DistanceScales {\n  const {latitude, longitude, highPrecision = false} = options;\n  assert(Number.isFinite(latitude) && Number.isFinite(longitude));\n\n  const worldSize = TILE_SIZE;\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n\n  /**\n   * Number of pixels occupied by one degree longitude around current lat/lon:\n     unitsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)\n       = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)\n     unitsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)\n       = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)\n   */\n  const unitsPerDegreeX = worldSize / 360;\n  const unitsPerDegreeY = unitsPerDegreeX / latCosine;\n\n  /**\n   * Number of pixels occupied by one meter around current lat/lon:\n   */\n  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n\n  /**\n   * LngLat: longitude -> east and latitude -> north (bottom left)\n   * UTM meter offset: x -> east and y -> north (bottom left)\n   * World space: x -> east and y -> south (top left)\n   *\n   * Y needs to be flipped when converting delta degree/meter to delta pixels\n   */\n  const result: DistanceScales = {\n    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],\n    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],\n\n    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],\n    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]\n  };\n\n  /**\n   * Taylor series 2nd order for 1/latCosine\n     f'(a) * (x - a)\n       = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat\n       = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat\n   */\n  if (highPrecision) {\n    const latCosine2 = (DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS)) / latCosine;\n    const unitsPerDegreeY2 = (unitsPerDegreeX * latCosine2) / 2;\n    const altUnitsPerDegree2 = (worldSize / EARTH_CIRCUMFERENCE) * latCosine2;\n    const altUnitsPerMeter2 = (altUnitsPerDegree2 / unitsPerDegreeY) * altUnitsPerMeter;\n\n    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];\n    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];\n  }\n\n  // Main results, used for converting meters to latlng deltas and scaling offsets\n  return result;\n}\n\n/**\n * Offset a lng/lat position by meterOffset (northing, easting)\n */\nexport function addMetersToLngLat(lngLatZ: number[], xyz: number[]): number[] {\n  const [longitude, latitude, z0] = lngLatZ;\n  const [x, y, z] = xyz;\n\n  // eslint-disable-next-line no-shadow\n  const {unitsPerMeter, unitsPerMeter2} = getDistanceScales({\n    longitude,\n    latitude,\n    highPrecision: true\n  });\n\n  const worldspace = lngLatToWorld(lngLatZ);\n  worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);\n  worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);\n\n  const newLngLat = worldToLngLat(worldspace);\n  const newZ = (z0 || 0) + (z || 0);\n\n  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;\n}\n\n/**\n *\n * view and projection matrix creation is intentionally kept compatible with\n * mapbox-gl's implementation to ensure that seamless interoperation\n * with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js\n */\nexport function getViewMatrix(options: {\n  // Viewport props\n  height: number;\n  pitch: number;\n  bearing: number;\n  altitude: number;\n  // Pre-calculated parameters\n  scale: number;\n  center?: number[];\n}): number[] {\n  const {\n    // Viewport props\n    height,\n    pitch,\n    bearing,\n    altitude,\n    // Pre-calculated parameters\n    scale,\n    center\n  } = options;\n  // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES\n  // Note that mercator world coordinates typically need to be flipped\n  //\n  // Note: As usual, matrix operation orders should be read in reverse\n  // since vectors will be multiplied from the right during transformation\n  const vm = createMat4();\n\n  // Move camera to altitude (along the pitch & bearing direction)\n  mat4.translate(vm, vm, [0, 0, -altitude]);\n\n  // Rotate by bearing, and then by pitch (which tilts the view)\n  mat4.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);\n  mat4.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);\n\n  const relativeScale = scale / height;\n  mat4.scale(vm, vm, [relativeScale, relativeScale, relativeScale]);\n\n  if (center) {\n    mat4.translate(vm, vm, vec3.negate([], center));\n  }\n\n  return vm;\n}\n\n/**\n * Calculates mapbox compatible projection matrix from parameters\n *\n * @param options.width Width of \"viewport\" or window\n * @param options.height Height of \"viewport\" or window\n * @param options.scale Scale at the current zoom\n * @param options.center Offset of the target, vec3 in world space\n * @param options.offset Offset of the focal point, vec2 in screen space\n * @param options.pitch Camera angle in degrees (0 is straight down)\n * @param options.fovy field of view in degrees\n * @param options.altitude if provided, field of view is calculated using `altitudeToFovy()`\n * @param options.nearZMultiplier control z buffer\n * @param options.farZMultiplier control z buffer\n * @returns project parameters object\n */\nexport function getProjectionParameters(options: {\n  width: number;\n  height: number;\n  scale?: number;\n  center?: number[];\n  offset?: [number, number];\n  fovy?: number;\n  altitude?: number;\n  pitch?: number;\n  nearZMultiplier?: number;\n  farZMultiplier?: number;\n}): ProjectionParameters {\n  const {\n    width,\n    height,\n    altitude,\n    pitch = 0,\n    offset,\n    center,\n    scale,\n    nearZMultiplier = 1,\n    farZMultiplier = 1\n  } = options;\n  let {fovy = altitudeToFovy(DEFAULT_ALTITUDE)} = options;\n\n  // For back-compatibility allow field of view to be\n  // derived from altitude\n  if (altitude !== undefined) {\n    fovy = altitudeToFovy(altitude);\n  }\n\n  const fovRadians = fovy * DEGREES_TO_RADIANS;\n  const pitchRadians = pitch * DEGREES_TO_RADIANS;\n\n  // Distance from camera to the target\n  const focalDistance = fovyToAltitude(fovy);\n\n  let cameraToSeaLevelDistance = focalDistance;\n\n  if (center) {\n    cameraToSeaLevelDistance += (center[2] * scale) / Math.cos(pitchRadians) / height;\n  }\n\n  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);\n\n  // Find the distance from the center point to the center top\n  // in focal distance units using law of sines.\n  const topHalfSurfaceDistance =\n    (Math.sin(fovAboveCenter) * cameraToSeaLevelDistance) /\n    Math.sin(clamp(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));\n\n  // Calculate z distance of the farthest fragment that should be rendered.\n  const furthestDistance =\n    Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;\n  // Matches mapbox limit\n  const horizonDistance = cameraToSeaLevelDistance * 10;\n\n  // Calculate z value of the farthest fragment that should be rendered.\n  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);\n\n  return {\n    fov: fovRadians,\n    aspect: width / height,\n    focalDistance,\n    near: nearZMultiplier,\n    far: farZ\n  };\n}\n\n/**\n * CALCULATE PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE\n *\n * To match mapbox's z buffer:\n *  - \\<= 0.28: nearZMultiplier: 0.1, farZmultiplier: 1\n *  - \\>= 0.29: nearZMultiplier: 1 / height, farZMultiplier: 1.01\n *\n * @param options Viewport options\n * @param options.width Width of \"viewport\" or window\n * @param options.height Height of \"viewport\" or window\n * @param options.scale Scale at the current zoom\n * @param options.center Offset of the target, vec3 in world space\n * @param options.offset Offset of the focal point, vec2 in screen space\n * @param options.pitch Camera angle in degrees (0 is straight down)\n * @param options.fovy field of view in degrees\n * @param options.altitude if provided, field of view is calculated using `altitudeToFovy()`\n * @param options.nearZMultiplier control z buffer\n * @param options.farZMultiplier control z buffer\n * @returns 4x4 projection matrix\n */\nexport function getProjectionMatrix(options: {\n  width: number;\n  height: number;\n  pitch: number;\n  scale?: number;\n  center?: number[];\n  offset?: [number, number];\n  fovy?: number;\n  altitude?: number;\n  nearZMultiplier: number;\n  farZMultiplier: number;\n}): number[] {\n  const {fov, aspect, near, far} = getProjectionParameters(options);\n\n  const projectionMatrix = mat4.perspective(\n    [] as number[],\n    fov, // fov in radians\n    aspect, // aspect ratio\n    near, // near plane\n    far // far plane\n  );\n\n  return projectionMatrix;\n}\n\n/**\n *\n * Convert an altitude to field of view such that the\n * focal distance is equal to the altitude\n *\n * @param altitude - altitude of camera in screen units\n * @return fovy field of view in degrees\n */\nexport function altitudeToFovy(altitude: number): number {\n  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;\n}\n\n/**\n *\n * Convert an field of view such that the\n * focal distance is equal to the altitude\n *\n * @param fovy - field of view in degrees\n * @return altitude altitude of camera in screen units\n */\nexport function fovyToAltitude(fovy: number): number {\n  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);\n}\n\n/**\n * Project flat coordinates to pixels on screen.\n *\n * @param xyz - flat coordinate on 512*512 Mercator Zoom 0 tile\n * @param pixelProjectionMatrix - projection matrix 4x4\n * @return [x, y, depth] pixel coordinate on screen.\n */\nexport function worldToPixels(xyz: number[], pixelProjectionMatrix: number[]): number[];\n\n// Project flat coordinates to pixels on screen.\nexport function worldToPixels(xyz: number[], pixelProjectionMatrix: number[]): number[] {\n  const [x, y, z = 0] = xyz;\n  assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));\n\n  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);\n}\n\n/**\n * Unproject pixels on screen to flat coordinates.\n *\n * @param xyz - pixel coordinate on screen.\n * @param pixelUnprojectionMatrix - unprojection matrix 4x4\n * @param targetZ - if pixel coordinate does not have a 3rd component (depth),\n *    targetZ is used as the elevation plane to unproject onto\n * @return [x, y, Z] flat coordinates on 512*512 Mercator Zoom 0 tile.\n */\nexport function pixelsToWorld(\n  xyz: number[],\n  pixelUnprojectionMatrix: number[],\n  targetZ: number = 0\n): number[] {\n  const [x, y, z] = xyz;\n  assert(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');\n\n  if (Number.isFinite(z)) {\n    // Has depth component\n    const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);\n    return coord;\n  }\n\n  // since we don't know the correct projected z value for the point,\n  // unproject two points to get a line and then find the point on that line with z=0\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);\n\n  const z0 = coord0[2];\n  const z1 = coord1[2];\n\n  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);\n  return vec2.lerp([] as number[], coord0, coord1, t);\n}\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: unknown, message?: string): void {\n  if (!condition) {\n    throw new Error(message || '@math.gl/web-mercator: assertion failed.');\n  }\n}\n", "import {assert} from './assert';\nimport {log2, clamp} from './math-utils';\nimport {MAX_LATITUDE, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\n\n/**\n * Options for fitBounds\n */\nexport type FitBoundsOptions = {\n  /**  viewport width  */\n  width: number;\n  /**  viewport height  */\n  height: number;\n  /**  [[lon, lat], [lon, lat]]  */\n  bounds: [[number, number], [number, number]];\n  /**  The width/height of the bounded area will never be smaller than this. 0.01 would be about 1000 meters (degree is ~110KM)  */\n  minExtent?: number;\n  /**  The maximum zoom level to fit the bounds within. */\n  maxZoom?: number; // ~x4,000,000 => About 10 meter extents\n  /**\n   * padding - The amount of padding in pixels to add to the given bounds.\n   * Can also be an object with top, bottom, left and right properties defining the padding.\n   */\n  padding?: number | Padding;\n  /** The center of the given bounds relative to the map's center,  */\n  offset?: number[];\n};\n\n/**\n * An object describing the padding to add to the bounds.\n */\nexport type Padding = {\n  /** Padding from top in pixels to add to the given bounds */\n  top: number;\n  /** Padding from bottom in pixels to add to the given bounds */\n  bottom: number;\n  /** Padding from left in pixels to add to the given bounds */\n  left: number;\n  /** Padding from right in pixels to add to the given bounds */\n  right: number;\n};\n\ntype ViewportProps = {\n  longitude: number;\n  latitude: number;\n  zoom: number;\n};\n\n/**\n * Returns map settings {latitude, longitude, zoom}\n * that will contain the provided corners within the provided width.\n *\n * > _Note: Only supports non-perspective mode._\n *\n * @param options fit bounds parameters\n * @returns - latitude, longitude and zoom\n */\nexport function fitBounds(options: FitBoundsOptions): ViewportProps {\n  const {\n    width,\n    height,\n    bounds,\n    minExtent = 0, // 0.01 would be about 1000 meters (degree is ~110KM)\n    maxZoom = 24, // ~x4,000,000 => About 10 meter extents\n    offset = [0, 0]\n  } = options;\n\n  const [[west, south], [east, north]] = bounds;\n  const padding = getPaddingObject(options.padding);\n\n  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n\n  // width/height on the Web Mercator plane\n  const size = [\n    Math.max(Math.abs(se[0] - nw[0]), minExtent),\n    Math.max(Math.abs(se[1] - nw[1]), minExtent)\n  ];\n\n  const targetSize = [\n    width - padding.left - padding.right - Math.abs(offset[0]) * 2,\n    height - padding.top - padding.bottom - Math.abs(offset[1]) * 2\n  ];\n\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n\n  // scale = screen pixels per unit on the Web Mercator plane\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n\n  // Find how much we need to shift the center\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n\n  const centerLngLat = worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n\n  assert(Number.isFinite(zoom));\n\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\n\n// Helpers\nfunction getPaddingObject(padding: number | Padding = 0): Padding {\n  if (typeof padding === 'number') {\n    return {\n      top: padding,\n      bottom: padding,\n      left: padding,\n      right: padding\n    };\n  }\n\n  // Make sure all the required properties are set\n  assert(\n    Number.isFinite(padding.top) &&\n      Number.isFinite(padding.bottom) &&\n      Number.isFinite(padding.left) &&\n      Number.isFinite(padding.right)\n  );\n\n  return padding;\n}\n", "/* eslint-disable camelcase */\nimport {vec2} from '@math.gl/core';\nimport type {WebMercatorViewport} from './web-mercator-viewport';\nimport {worldToLngLat} from './web-mercator-utils';\nimport {transformVector} from './math-utils';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\n/*\n * Returns the quad at the intersection of the frustum and the given z plane\n * @param {WebMercatorViewport} viewport\n * @param {Number} z - elevation in meters\n */\nexport function getBounds(viewport: WebMercatorViewport, z: number = 0): number[][] {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  const {width, height, unproject} = viewport;\n  const unprojectOps = {targetZ: z};\n  const bottomLeft = unproject([0, height], unprojectOps);\n  const bottomRight = unproject([width, height], unprojectOps);\n  let topLeft: number[];\n  let topRight: number[];\n\n  const halfFov = viewport.fovy\n    ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS\n    : Math.atan(0.5 / viewport.altitude);\n  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS;\n  // The top plane is parallel to the ground if halfFov == angleToGround\n  if (halfFov > angleToGround - 0.01) {\n    // intersect with the far plane\n    topLeft = unprojectOnFarPlane(viewport, 0, z);\n    topRight = unprojectOnFarPlane(viewport, width, z);\n  } else {\n    // intersect with the top plane\n    topLeft = unproject([0, 0], unprojectOps);\n    topRight = unproject([width, 0], unprojectOps);\n  }\n\n  return [bottomLeft, bottomRight, topRight, topLeft];\n}\n\n/*\n * Find a point on the far clipping plane of the viewport\n * @param {WebMercatorViewport} viewport\n * @param {Number} x - projected x in screen space\n * @param {Number} targetZ - the elevation of the point in meters\n */\nfunction unprojectOnFarPlane(viewport: WebMercatorViewport, x: number, targetZ: number): number[] {\n  const {pixelUnprojectionMatrix} = viewport;\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);\n\n  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];\n  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);\n  const coord = vec2.lerp([], coord0, coord1, t);\n\n  const result = worldToLngLat(coord);\n  result.push(targetZ);\n  return result;\n}\n", "// View and Projection Matrix calculations for mapbox-js style map view properties\nimport {createMat4} from './math-utils';\n\nimport {\n  zoomToScale,\n  pixelsToWorld,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  altitudeToFovy,\n  fovyToAltitude,\n  DEFAULT_ALTITUDE,\n  getProjectionMatrix,\n  getDistanceScales,\n  getViewMatrix,\n  DistanceScales\n} from './web-mercator-utils';\nimport {fitBounds} from './fit-bounds';\nimport {getBounds} from './get-bounds';\nimport type {FitBoundsOptions} from './fit-bounds';\n\nimport {mat4, vec2, vec3} from '@math.gl/core';\n\n/**\n   * @param width=1 - Width of \"viewport\" or window\n   * @param height=1 - Height of \"viewport\" or window\n   * @param scale=1 - Either use scale or zoom\n   * @param pitch=0 - Camera angle in degrees (0 is straight down)\n   * @param bearing=0 - Map rotation in degrees (0 means north is up)\n   * @param fovy= - Field of view of camera in degrees\n   * @param altitude= - Altitude of camera in screen units                                                               \n   *\n   * Web mercator projection short-hand parameters\n   * @param latitude - Center of viewport on map\n   * @param longitude - Center of viewport on map\n   * @param zoom - Scale = Math.pow(2,zoom) on map\n\n   * Notes:\n   *  - Only one of center or [latitude, longitude] can be specified\n   *  - [latitude, longitude] can only be specified when \"mercator\" is true\n   *  - Altitude has a default value that matches assumptions in mapbox-gl\n   *  - Field of view is independent from altitude, provide `altitudeToFovy(1.5)` (default value) to match assumptions in mapbox-gl\n   *  - width and height are forced to 1 if supplied as 0, to avoid\n   *    division by zero. This is intended to reduce the burden of apps to\n   *    to check values before instantiating a Viewport.\n */\nexport type WebMercatorViewportProps = {\n  // Map state\n  width: number;\n  height: number;\n  latitude?: number;\n  longitude?: number;\n  position?: number[];\n  zoom?: number;\n  pitch?: number;\n  bearing?: number;\n  altitude?: number;\n  fovy?: number;\n  nearZMultiplier?: number;\n  farZMultiplier?: number;\n};\n\n/**\n * The WebMercatorViewport class creates\n * - view/projection matrices\n * - \"uniform values\" (for shaders) from mercator params\n *\n * Note: Instances are immutable in the sense that they only have accessors.\n * A new viewport instance should be created if any parameters have changed.\n */\nexport class WebMercatorViewport {\n  readonly latitude: number;\n  readonly longitude: number;\n  readonly zoom: number;\n  readonly pitch: number;\n  readonly bearing: number;\n  readonly altitude: number;\n  readonly fovy: number;\n\n  readonly meterOffset: number[];\n  readonly center: number[];\n\n  readonly width: number;\n  readonly height: number;\n  readonly scale: number;\n  readonly distanceScales: DistanceScales;\n\n  readonly viewMatrix: number[];\n  readonly projectionMatrix: number[];\n\n  viewProjectionMatrix: number[];\n  pixelProjectionMatrix: number[];\n  pixelUnprojectionMatrix: number[];\n\n  /**\n   * @classdesc\n   * Creates view/projection matrices from mercator params\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   */\n  // eslint-disable-next-line max-statements\n  constructor(props: WebMercatorViewportProps = {width: 1, height: 1}) {\n    let {\n      // Map state\n      width,\n      height,\n      altitude = null,\n      fovy = null\n    } = props;\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = props;\n\n    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n    width = width || 1;\n    height = height || 1;\n\n    // `fovy` & `altitude` are independent parameters, one for the\n    // projection and the latter for the view matrix. In the past,\n    // the `fovy` was always derived from the `altitude`\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n\n    const scale = zoomToScale(zoom);\n    // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n    altitude = Math.max(0.75, altitude);\n\n    const distanceScales = getDistanceScales({longitude, latitude});\n\n    const center: number[] = lngLatToWorld([longitude, latitude]);\n    center.push(0);\n\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      scale,\n      center,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n\n    // Save parameters\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    Object.freeze(this);\n  }\n\n  _initMatrices(): void {\n    const {width, height, projectionMatrix, viewMatrix} = this;\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // Calculate matrices and scales needed for projection\n    /**\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    const m = createMat4();\n\n    // matrix for conversion from location to screen coordinates\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n\n    const mInverse = mat4.invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n\n  /** Two viewports are equal if width and height are identical, and if\n   * their view and projection matrices are (approximately) equal.\n   */\n  equals = (viewport: WebMercatorViewport | null): boolean => {\n    if (!(viewport instanceof WebMercatorViewport)) {\n      return false;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      mat4.equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      mat4.equals(viewport.viewMatrix, this.viewMatrix)\n    );\n  };\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param options - options\n   * @param options.topLeft=true - Whether projected coords are top left\n   * @return - screen coordinates [x, y] or [x, y, z], z as pixel depth\n   */\n  project = (lngLatZ: number[], options: {topLeft?: boolean} = {}): number[] => {\n    const {topLeft = true} = options;\n    const worldPosition = this.projectPosition(lngLatZ);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  };\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates, possibly `[lon, lat]` on map.\n   *\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   *\n   * @param xyz - screen coordinates, z as pixel depth\n   * @param options - options\n   * @param options.topLeft=true - Whether projected coords are top left\n   * @param options.targetZ=0 - If pixel depth is unknown, targetZ is used as\n   *   the elevation plane to unproject onto\n   * @return - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject = (xyz: number[], options: {topLeft?: boolean; targetZ?: number} = {}): number[] => {\n    const {topLeft = true, targetZ = undefined} = options;\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  };\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition = (xyz: number[]): [number, number, number] => {\n    const [X, Y] = lngLatToWorld(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  };\n\n  unprojectPosition = (xyz: number[]): [number, number, number] => {\n    const [X, Y] = worldToLngLat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  };\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   *\n   * @param lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return [x,y] coordinates.\n   */\n  projectFlat(lngLat: number[]): number[] {\n    return lngLatToWorld(lngLat);\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   *\n   * @param xy - array with [x,y] members\n   *  representing point on projected map plane\n   * @return - array with [lat,lon] of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xy: number[]): number[] {\n    return worldToLngLat(xy);\n  }\n\n  /**\n   * Get the map center that place a given [lng, lat] coordinate at screen point [x, y]\n   * @param opt\n   * @param opt.lngLat - [lng,lat] coordinates\n   *   Specifies a point on the sphere.\n   * @param opt.pos - [x,y] coordinates\n   *   Specifies a point on the screen.\n   * @return [lng,lat] new map center.\n   */\n  getMapCenterByLngLatPosition({lngLat, pos}: {lngLat: number[]; pos: number[]}): number[] {\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n\n  /**\n   * Returns a new viewport that fit around the given rectangle.\n   * Only supports non-perspective mode.\n   * @param bounds - [[lon, lat], [lon, lat]]\n   * @param [options]\n   * @param [options.padding] - The amount of padding in pixels to add to the given bounds.\n   * @param [options.offset] - The center of the given bounds relative to the map's center,\n   *    [x, y] measured in pixels.\n   * @returns {WebMercatorViewport}\n   */\n  fitBounds(\n    bounds: [[number, number], [number, number]],\n    options: Omit<FitBoundsOptions, 'width' | 'height' | 'bounds'> = {}\n  ): WebMercatorViewport {\n    const {width, height} = this;\n    const {longitude, latitude, zoom} = fitBounds(Object.assign({width, height, bounds}, options));\n    return new WebMercatorViewport({width, height, longitude, latitude, zoom});\n  }\n\n  /**\n   * Returns the bounding box of the viewport.\n   * @param [options]\n   * @param [options.z] - The altitude at which the bounds should be calculated.\n   * @returns {Array} bounds - [[lon, lat], [lon, lat]]\n   */\n  getBounds(options?: {z?: number}): number[][] {\n    const corners = this.getBoundingRegion(options);\n\n    const west = Math.min(...corners.map((p) => p[0]));\n    const east = Math.max(...corners.map((p) => p[0]));\n    const south = Math.min(...corners.map((p) => p[1]));\n    const north = Math.max(...corners.map((p) => p[1]));\n    return [\n      [west, south],\n      [east, north]\n    ];\n  }\n\n  /**\n   * Returns the bounding box of the viewport.\n   * @param [options]\n   * @param [options.z] - The altitude at which the bounds should be calculated.\n   * @returns {Array} an array of 4 points that define the visible region\n   */\n  getBoundingRegion(options: {z?: number} = {}): number[][] {\n    return getBounds(this, options.z || 0);\n  }\n\n  // DEPRECATED\n\n  /** @deprecated Legacy method name */\n  getLocationAtPoint({lngLat, pos}: {lngLat: number[]; pos: number[]}): number[] {\n    return this.getMapCenterByLngLatPosition({lngLat, pos});\n  }\n}\n", "import {worldToLngLat} from './web-mercator-utils';\nimport {mod, log2} from './math-utils';\n\n// defined by mapbox-gl\nconst TILE_SIZE = 512;\n\n/** Description of viewport */\nexport type ViewportProps = {\n  width: number;\n  height: number;\n  longitude: number;\n  latitude: number;\n  zoom: number;\n  pitch?: number;\n  bearing?: number;\n};\n\n/**\n * Apply mathematical constraints to viewport props\n * @param props\n */\n// eslint-disable-next-line complexity\nexport function normalizeViewportProps(props: ViewportProps): ViewportProps {\n  const {width, height, pitch = 0} = props;\n  let {longitude, latitude, zoom, bearing = 0} = props;\n\n  // Normalize degrees\n  if (longitude < -180 || longitude > 180) {\n    longitude = mod(longitude + 180, 360) - 180;\n  }\n  if (bearing < -180 || bearing > 180) {\n    bearing = mod(bearing + 180, 360) - 180;\n  }\n\n  // Constrain zoom and shift center at low zoom levels\n  const minZoom = log2(height / TILE_SIZE);\n  if (zoom <= minZoom) {\n    zoom = minZoom;\n    latitude = 0;\n  } else {\n    // Eliminate white space above and below the map\n    const halfHeightPixels = height / 2 / Math.pow(2, zoom);\n    const minLatitude = worldToLngLat([0, halfHeightPixels])[1];\n    if (latitude < minLatitude) {\n      latitude = minLatitude;\n    } else {\n      const maxLatitude = worldToLngLat([0, TILE_SIZE - halfHeightPixels])[1];\n      if (latitude > maxLatitude) {\n        latitude = maxLatitude;\n      }\n    }\n  }\n\n  return {width, height, longitude, latitude, zoom, pitch, bearing};\n}\n", "import {lerp} from './math-utils';\nimport {scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\nimport {vec2} from '@math.gl/core';\n\nimport type {ViewportProps} from './normalize-viewport-props';\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'] as const;\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n  // screenSpeed and maxDuration are used only if specified\n};\n\nexport type FlytoTransitionOptions = {\n  curve?: number;\n  speed?: number;\n  screenSpeed?: number;\n  maxDuration?: number;\n};\n\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements \u201CSmooth and efficient zooming and panning.\u201D algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n */\nexport function flyToViewport(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  t: number,\n  options?: FlytoTransitionOptions\n): {\n  longitude: number;\n  latitude: number;\n  zoom: number;\n} {\n  // Equations from above paper are referred where needed.\n\n  const {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0} = getFlyToTransitionParams(\n    startProps,\n    endProps,\n    options\n  );\n\n  // If change in center is too small, do linear interpolaiton.\n  if (u1 < EPSILON) {\n    const viewport = {};\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      // @ts-ignore-error properties are populated dynamically\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n    // @ts-expect-error properties are populated dynamically\n    return viewport;\n  }\n\n  const s = t * S;\n\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = (w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2)) / u1;\n\n  const scaleIncrement = 1 / w; // Using w method for scaling.\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n\n  const newCenter = worldToLngLat(newCenterWorld);\n  return {\n    longitude: newCenter[0],\n    latitude: newCenter[1],\n    zoom: newZoom\n  };\n}\n\n// returns transition duration in milliseconds\nexport function getFlyToDuration(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  options?: FlytoTransitionOptions\n): number {\n  const opts = {...DEFAULT_OPTS, ...options};\n  const {screenSpeed, speed, maxDuration} = opts;\n  const {S, rho} = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration: number;\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\n// Private Methods\n\n// Calculate all parameters that are static for given startProps and endProps\nfunction getFlyToTransitionParams(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  opts: FlytoTransitionOptions\n): {\n  startZoom: number;\n  startCenterXY: number[];\n  uDelta: number[];\n  w0: number;\n  u1: number;\n  S: number;\n  rho: number;\n  rho2: number;\n  r0: number;\n  r1: number;\n} {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2.sub([] as number[], endCenterXY, startCenterXY);\n\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta) * startScale;\n  // u0 is treated as '0' in Eq (9).\n\n  // If u1 is too small, will generate invalid number\n  const _u1 = Math.max(u1, EPSILON);\n\n  // Implement Equation (9) from above algorithm.\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n\n  return {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0, r1};\n}\n"],
  "mappings": "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",
  "names": ["import_core", "unitsPerMeter", "unitsPerMeter2", "import_core", "DEGREES_TO_RADIANS", "import_core", "TILE_SIZE", "import_core"]
}
